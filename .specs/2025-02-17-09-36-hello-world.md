---
tinySpec: v0
title: Scaffolding tiny spec
applications:
  - tinyspec
---

# Background

There are a number of specification standards such as [OpenSpec](https://github.com/Fission-AI/OpenSpec), [SpecKit](https://github.com/github/spec-kit), and [GetShitDone](https://github.com/gsd-build/get-shit-done). These tend to be heavyweight and opinionated. TinySpec aims to fill the gap for a minimal, markdown-native format that works well with language models.

# Proposal

TinySpec is a simple, lightweight specification format for describing software components and their interactions. Specs should be:

- Easy to read and write
- Useful for planning work and instructing a language model
- Able to provide system context to a language model

Specifications are written in markdown and stored in a `.specs/` directory at the root of a project.

## Front Matter

Specs use YAML front matter to define metadata:

- `tinySpec`: The tinySpec format version (e.g. `v0`)
- `title`: A human-readable title for the spec
- `applications`: A list of applications or services affected by this spec

## Sections

The body of a tinySpec has a clear structure. Each H1 heading maps to a standard section:

- **Background** \[Written by user\]: Provide context on the domain and the problem being solved.
- **Proposal** \[Written by user\]: Describe the proposed changes in prose. Direct the language model to relevant code, APIs, or documentation needed for implementation.
- **Implementation Plan** \[Scaffolded by agent, refined by user\]: A step-by-step plan for implementing the proposal. Uses markdown checkboxes to track completion. Tasks can be nested to indicate subtasks, and each task can span multiple lines for longer descriptions.
- **Test Plan** (Optional) \[Scaffolded by agent, refined by user\]: Defines the test cases that need to be implemented. Only populated when the user wants tests written. Each test case uses **Given** / **When** / **Then** syntax to clearly describe preconditions, actions, and expected outcomes.

## CLI Commands

TinySpec provides the following commands:

- `tinyspec init`: Set up Claude Code slash command skills for working with tinyspec (see below).
- `tinyspec new <spec-name>`: Create a new spec with the given name, generating a markdown file with front matter and section headers.
  - The spec-name should be in kebab-case. The filename is prefixed with a timestamp: `YYYY-MM-DD-HH-MM-<spec-name>.md`. The timestamp ensures uniqueness and natural ordering.
- `tinyspec list`: List all specs in the project, showing their titles and status.
- `tinyspec view <spec-name>`: Display the content of a specific spec.
- `tinyspec edit <spec-name>`: Open a specific spec in the default editor.
- `tinyspec delete <spec-name>`: Delete a specific spec from the project.
- `tinyspec check <spec-name> <task-id>`: Mark a task as complete (e.g. `tinyspec check hello-world A.1`).
- `tinyspec uncheck <spec-name> <task-id>`: Mark a task as incomplete.
- `tinyspec status [spec-name]`: Show completion progress for a spec (or all specs if no name given).

## Claude Code Skills

Running `tinyspec init` generates custom slash commands in the project's `.claude/commands/` directory. These skills allow users to collaborate with Claude directly on specs:

- **`/spec-refine <spec-name>`**: Cowork through a spec with Claude. Claude reads the spec, helps the user refine the Background and Proposal sections, then scaffolds or updates the Implementation Plan and Test Plan. This is a conversational workflow — Claude asks questions, suggests improvements, and waits for user approval before making changes.

- **`/spec-work <spec-name>`**: Iterate through a spec's Implementation Plan. Claude reads the spec, identifies the next uncompleted task, implements it, marks it complete with `tinyspec check`, and moves on to the next task. Claude should commit progress after each top-level task group is finished.

- **`/spec-task <spec-name> <task-id>`**: Complete a specific task within a spec. Claude reads the spec for context, implements just the specified task, and marks it complete. Useful when the user wants to skip ahead or work on tasks out of order.

Each skill is a markdown prompt file that instructs Claude on the workflow, references the spec file, and uses the tinyspec CLI to read and update task status.

## Shell Tab Completion

TinySpec uses `clap_complete` with the `unstable-dynamic` feature to provide runtime shell completions. Any command that takes a `<spec-name>` argument (view, edit, delete, check, uncheck, status) will dynamically complete spec names by reading `.specs/` at tab-completion time and stripping the timestamp prefix.

This is powered by `CompleteEnv` — when the shell invokes `COMPLETE=zsh tinyspec`, the binary outputs completion suggestions and exits. Users register completions in their shell config:

- **Bash**: `source <(COMPLETE=bash tinyspec)`
- **Zsh**: `source <(COMPLETE=zsh tinyspec)`
- **Fish**: `COMPLETE=fish tinyspec | source`

The `tinyspec init` command should print these instructions for the user's detected shell.

## Task Identifiers

Each task in the Implementation Plan and Test Plan is prefixed with an identifier for easy reference from the CLI:

```
- [x] A: Do this
         A multiline description of the task
    - [x] A.1: Do this subtask
    - [x] A.2: Do this other subtask

- [x] B: Do this other thing
```

Task IDs follow a hierarchical pattern (A, A.1, A.2, B, B.1, etc.) and are used by the `check`/`uncheck` commands. It's important that the task IDs (e.g. portion before the colon) are unique within a spec to avoid ambiguity.

# Implementation Plan

- [x] A: Set up the Rust project structure
  
  - [x] A.1: Initialize with `cargo init` and configure `Cargo.toml` (name, version, description)
  - [x] A.2: Add dependencies: `clap` (CLI parsing), `clap_complete` with `unstable-dynamic` feature (shell completions), `serde` + `serde_yaml` (front matter parsing), `chrono` (timestamps)
  - [x] A.3: Set up the `clap` subcommand structure in `main.rs` with stubs for each command
- [x] B: Implement `tinyspec new <spec-name>`
  
  - [x] B.1: Validate spec-name is kebab-case
  - [x] B.2: Generate the timestamped filename (`YYYY-MM-DD-HH-MM-<spec-name>.md`)
  - [x] B.3: Create `.specs/` directory if it does not exist
  - [x] B.4: Write the markdown template with front matter and section headers
- [x] C: Implement `tinyspec list`
  
  - [x] C.1: Read all `.md` files from `.specs/`
  - [x] C.2: Parse front matter to extract title
  - [x] C.3: Display a formatted list with filename and title
- [x] D: Implement `tinyspec view <spec-name>`
  
  - [x] D.1: Resolve spec-name to a file (allow partial match on the name portion)
  - [x] D.2: Print the file contents to stdout
- [x] E: Implement `tinyspec edit <spec-name>`
  
  - [x] E.1: Resolve spec-name to a file
  - [x] E.2: Open in `$EDITOR` (or fall back to a sensible default)
- [x] F: Implement `tinyspec delete <spec-name>`
  
  - [x] F.1: Resolve spec-name to a file
  - [x] F.2: Prompt for confirmation before deleting
- [x] G: Implement `tinyspec check` / `uncheck <spec-name> <task-id>`
  
  - [x] G.1: Parse the spec's markdown to locate the checkbox line matching the task ID
  - [x] G.2: Toggle `[ ]` to `[x]` (or vice versa) and write the file back
- [x] H: Implement `tinyspec status [spec-name]`
  
  - [x] H.1: Parse checkbox counts from the Implementation Plan and Test Plan sections
  - [x] H.2: Display completion summary (e.g. `3/7 tasks complete`)
- [x] I: Implement `tinyspec init`
  
  - [x] I.1: Create `.claude/commands/` directory if it does not exist
  - [x] I.2: Generate `spec-refine.md` skill prompt
  - [x] I.3: Generate `spec-work.md` skill prompt
  - [x] I.4: Generate `spec-task.md` skill prompt
  - [x] I.5: Skip generation for any skill files that already exist (do not overwrite)
  - [x] I.6: Print shell completion setup instructions for the user's detected shell
- [x] J: Implement shell tab completion
  
  - [x] J.1: Write a `complete_spec_names` function that reads `.specs/`, strips timestamp prefixes, and returns `CompletionCandidate` values
  - [x] J.2: Wire `CompleteEnv::with_factory(...)` into `main()` before argument parsing
  - [x] J.3: Add `ArgValueCompleter::new(complete_spec_names)` to the `<spec-name>` argument on all subcommands that accept it (view, edit, delete, check, uncheck, status)

# Test Plan

- [x] T.1: Create a new spec with valid name
  
  - **Given** the `.specs/` directory exists
  - **When** the user runs `tinyspec new my-feature`
  - **Then** a file named `YYYY-MM-DD-HH-MM-my-feature.md` is created in `.specs/`
  - **And** the file contains valid YAML front matter with `tinySpec`, `title`, and `applications` fields
  - **And** the file contains `# Background`, `# Proposal`, `# Implementation Plan`, and `# Test Plan` section headers
- [x] T.2: Reject invalid spec names
  
  - **Given** the `.specs/` directory exists
  - **When** the user runs `tinyspec new "My Feature"` (or names with uppercase, spaces, or special characters)
  - **Then** the command exits with a non-zero status
  - **And** a helpful error message explains the kebab-case naming requirement
- [x] T.3: List all specs
  
  - **Given** the `.specs/` directory contains two or more spec files
  - **When** the user runs `tinyspec list`
  - **Then** all specs are listed with their filename and title
  - **And** the list is sorted by date (oldest first)
- [x] T.4: View an existing spec
  
  - **Given** a spec named `2025-02-17-09-36-hello-world.md` exists in `.specs/`
  - **When** the user runs `tinyspec view hello-world`
  - **Then** the full contents of the spec are printed to stdout
- [x] T.5: View a non-existent spec
  
  - **Given** no spec matching `nonexistent` exists in `.specs/`
  - **When** the user runs `tinyspec view nonexistent`
  - **Then** the command exits with a non-zero status
  - **And** a helpful error message is displayed
- [x] T.6: Delete a spec
  
  - **Given** a spec named `2025-02-17-09-36-hello-world.md` exists in `.specs/`
  - **When** the user runs `tinyspec delete hello-world` and confirms the prompt
  - **Then** the file is removed from `.specs/`
  - **And** no other files are affected
- [x] T.7: Check a task
  
  - **Given** a spec exists with an unchecked task `- [ ] A: Do this`
  - **When** the user runs `tinyspec check hello-world A`
  - **Then** the task line in the file is updated to `- [x] A: Do this`
  - **And** no other lines in the file are modified
- [x] T.8: Uncheck a task
  
  - **Given** a spec exists with a checked task `- [x] B: Do that`
  - **When** the user runs `tinyspec uncheck hello-world B`
  - **Then** the task line in the file is updated to `- [ ] B: Do that`
- [x] T.9: Check with an invalid task ID
  
  - **Given** a spec exists with tasks A and B only
  - **When** the user runs `tinyspec check hello-world Z`
  - **Then** the command exits with a non-zero status
  - **And** a helpful error message indicates the task ID was not found
- [x] T.10: Show status for a spec
  
  - **Given** a spec exists with 3 of 7 tasks checked
  - **When** the user runs `tinyspec status hello-world`
  - **Then** the output displays `3/7 tasks complete`
- [x] T.11: Init creates skill files
  
  - **Given** the `.claude/commands/` directory does not exist
  - **When** the user runs `tinyspec init`
  - **Then** the `.claude/commands/` directory is created
  - **And** `spec-refine.md`, `spec-work.md`, and `spec-task.md` are written to it
  - **And** each file contains a valid skill prompt
- [x] T.12: Init does not overwrite existing skill files
  
  - **Given** `.claude/commands/spec-refine.md` already exists with custom content
  - **When** the user runs `tinyspec init`
  - **Then** `spec-refine.md` is not modified
  - **And** any missing skill files are still created
- [x] T.13: Tab completion suggests spec names
  
  - **Given** `.specs/` contains `2025-02-17-09-36-hello-world.md` and `2025-03-01-14-00-auth-flow.md`
  - **When** the user types `tinyspec view ` and presses tab
  - **Then** `hello-world` and `auth-flow` are offered as completions (timestamps stripped)
- [x] T.14: Init prints shell completion instructions
  
  - **Given** the user's shell is zsh
  - **When** the user runs `tinyspec init`
  - **Then** the output includes the line `source <(COMPLETE=zsh tinyspec)`
